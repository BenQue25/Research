<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>METACOGNITION — Research Paper</title>
  <meta name="description" content="METACOGNITION: A Paradigm Shift in Algorithmic Trading Through Sophisticated Simplicity" />
  <style>
    :root{
      --bg:#d9d0c2; /* warm beige similar to the reference */
      --ink:#111;   /* near black */
      --muted:#333;
      --rule:#bfb6a6;
      --accent:#111;
      --font-sans:-apple-system, BlinkMacSystemFont, "Inter", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }
    html,body{height:100%;}
    html{box-sizing:border-box}
    *,*:before,*:after{box-sizing:inherit}
    body{
      margin:0; color:var(--ink); background:var(--bg); font-family:var(--font-sans);
      -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility;
    }
    /* Top bar */
    .topbar{
      border-bottom:1px solid var(--rule); background:var(--bg);
      display:flex; align-items:center; gap:16px; padding:12px 20px;
      overflow:hidden; /* prevent transformed content from overlapping sections */
    }
    .logo{height:96px; width:auto; display:block}
    .logo-react{height:96px; width:min(42vw, 460px); display:block; flex:0 0 auto}
    @media (max-width: 768px){ .logo-react{height:72px; width:min(60vw, 360px)} }
    @media (max-width: 480px){ .logo-react{height:60px; width:85vw} }
    .paper-meta{margin-left:auto; display:flex; gap:16px; color:var(--muted); font-size:14px}
    .container{max-width:1200px; margin:0 auto; padding:24px;}

    /* HERO wordmark matching IDENTIFONT scale */
    .topbar, .hero, main{ position:relative; z-index:1 }
    .hero{
      border-bottom:1px solid var(--rule);
      background:var(--bg);
      position:relative; overflow-x:visible; overflow-y:hidden;
    }
    .wordmark{
      margin:0; line-height:0.9; letter-spacing:-0.02em; color:var(--ink);
      font-weight:900; text-transform:uppercase;
      font-size: clamp(48px, 14vw, 144px);
    }
    .hero-bg{position:absolute; inset:0; pointer-events:none; overflow:hidden}
    .hero-bg #ascii-flow{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      line-height:0.85; letter-spacing:0.05em; color:rgba(0,0,0,0.18);
      user-select:none; opacity:0.85;
    }
    /* (Removed) page ASCII patches */
    .grid-nav{
      display:grid; grid-template-columns:repeat(4,1fr); gap:0; border-top:1px solid var(--rule);
      border-left:1px solid var(--rule); margin-top:18px; margin-bottom:18px;
    }
    .grid-nav .cell{
      border-right:1px solid var(--rule); border-bottom:1px solid var(--rule);
      padding:18px 20px; display:flex; align-items:center; justify-content:space-between; color:var(--muted);
      font-weight:600; text-transform:uppercase; letter-spacing:0.06em; font-size:12px;
    }

    main{padding-top:20px}
    h1,h2,h3{font-weight:900; text-transform:uppercase; letter-spacing:0.02em}
    h1{font-size:40px; margin:36px 0 8px}
    h2{font-size:28px; margin:28px 0 8px}
    h3{font-size:18px; margin:20px 0 6px; color:var(--muted)}
    p{line-height:1.6; margin:10px 0}
    ul{margin:10px 0 10px 20px}
    li{margin:6px 0}

    table{width:100%; border-collapse:collapse; margin:16px 0;}
    th,td{border:1px solid var(--rule); padding:10px; text-align:left}
    th{background:rgba(0,0,0,0.04)}

    .footer{color:var(--muted); font-size:14px; margin-top:20px}

    /* Scrollbar styling (body + hero) */
    body, .hero{scrollbar-width:thin; scrollbar-color: var(--ink) var(--bg);} /* Firefox */
    /* WebKit */
    body::-webkit-scrollbar, .hero::-webkit-scrollbar{width:12px; height:12px}
    body::-webkit-scrollbar-track, .hero::-webkit-scrollbar-track{background:var(--bg); border-left:1px solid var(--rule)}
    body::-webkit-scrollbar-thumb, .hero::-webkit-scrollbar-thumb{
      background: var(--ink);
      border: 2px solid var(--bg);
      border-radius: 8px;
    }
    body::-webkit-scrollbar-thumb:hover, .hero::-webkit-scrollbar-thumb:hover{background:#000}

    /* Print */
    @media print{
      .topbar,.grid-nav,.hero{display:none}
      body{background:white; color:black}
      a:after{content:" (" attr(href) ")"}
    }

    /* Mobile (iPhone) adjustments */
    @media (max-width: 768px){
      .container{padding:16px}
      .logo{height:72px}
      .wordmark{font-size: clamp(40px, 12vw, 96px)}
      .grid-nav{grid-template-columns:repeat(2,1fr)}
      .grid-nav .cell{font-size:11px; padding:14px}
      h1{font-size:32px}
      h2{font-size:24px}
      h3{font-size:16px}
    }
    @media (max-width: 480px){
      .container{padding:14px}
      .logo{height:60px}
      .grid-nav{grid-template-columns:1fr}
      .wordmark{font-size: clamp(32px, 9.5vw, 72px); letter-spacing:-0.01em}
    }
    /* Make tables scrollable on narrow screens */
    @media (max-width: 768px){
      table{display:block; overflow-x:auto; -webkit-overflow-scrolling:touch; white-space:nowrap}
      th,td{min-width:140px}
    }
    @media (max-width: 768px){
      body::-webkit-scrollbar, .hero::-webkit-scrollbar{width:8px; height:8px}
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div id="logo-react" class="logo-react" aria-label="METACOGNITION Logo Visualization"></div>
    <div class="paper-meta">
      <span>METACOGNITION TRADING RESEARCH</span>
      <span>2025</span>
    </div>
  </header>

  <section class="hero">
    <div class="hero-bg" aria-hidden="true"><div id="ascii-flow"></div></div>
    <div class="container">
      <h1 class="wordmark">METACOGNITION</h1>
      <div class="grid-nav" aria-hidden="true">
        <div class="cell"><span>Signal Engineering</span><span>→</span></div>
        <div class="cell"><span>Adaptive Position Sizing</span><span>→</span></div>
        <div class="cell"><span>Market Microstructure</span><span>→</span></div>
        <div class="cell"><span>AI Research & Backtesting</span><span>→</span></div>
      </div>
    </div>
  </section>

  <main class="container" role="main">
    <article>
      <h1>A Paradigm Shift in Algorithmic Trading Through Sophisticated Simplicity</h1>

      <h2>Abstract</h2>
      <p>
        This research presents a revolutionary approach to algorithmic trading that challenges conventional complexity paradigms. Through the application of advanced market microstructure analysis and adaptive position sizing algorithms, we demonstrate that sophisticated simplicity in algorithmic design produces superior risk-adjusted returns. Our proprietary model achieves unprecedented performance metrics across multiple volatility indices, with a primary index return of 10,521,583.90% while maintaining a maximum drawdown of only 3.01%.
      </p>

      <h2>1. Introduction</h2>
      <h3>1.1 The Complexity Paradox</h3>
      <p>
        Traditional algorithmic trading systems have followed a path of increasing complexity, incorporating hundreds of technical indicators, machine learning models, and multi-factor analysis frameworks. However, this approach often leads to overfitting, reduced robustness, and diminished performance in live trading environments. The METACOGNITION model represents a fundamental departure from this paradigm, demonstrating that mathematical elegance and adaptive simplicity can achieve superior results.
      </p>

      <h3>1.2 Research Objectives</h3>
      <ul>
        <li>Establish the theoretical foundation for sophisticated simplicity in algorithmic trading</li>
        <li>Demonstrate the superior performance of adaptive position sizing over static approaches</li>
        <li>Analyze the relationship between market microstructure and algorithmic efficiency</li>
        <li>Provide empirical evidence of the model's robustness across multiple volatility regimes</li>
      </ul>

      <h2>2. Theoretical Framework</h2>
      <h3>2.1 Market Microstructure Foundation</h3>
      <p>
        The METACOGNITION model is built upon the fundamental principles of market microstructure theory, specifically leveraging the relationship between volatility dynamics and directional momentum. Our research identifies that volatility indices exhibit unique characteristics that create predictable patterns when properly harnessed through sophisticated algorithmic design.
      </p>

      <h3>2.2 The Sophisticated Simplicity Principle</h3>
      <ul>
        <li><strong>Mathematical Elegance</strong>: Clean, efficient algorithms that minimize computational overhead</li>
        <li><strong>Adaptive Architecture</strong>: Systems that evolve with market conditions without manual intervention</li>
        <li><strong>Risk Management Integration</strong>: Position sizing algorithms that automatically adjust to performance metrics</li>
        <li><strong>Market Microstructure Leverage</strong>: Exploitation of predictable market inefficiencies</li>
      </ul>

      <h3>2.3 Position Sizing Algorithm</h3>
      <p>The model incorporates an advanced position sizing algorithm based on the Kelly Criterion, modified for real-time market conditions. This algorithm dynamically adjusts position sizes based on:</p>
      <ul>
        <li>Current win rate performance</li>
        <li>Risk-adjusted return metrics</li>
        <li>Market volatility conditions</li>
        <li>Portfolio drawdown constraints</li>
      </ul>

      <h2>3. Methodology</h2>
      <h3>3.1 Data Collection and Processing</h3>
      <p>Our research utilizes high-frequency tick data from multiple volatility indices, including:</p>
      <ul>
        <li>Volatility 100 Index (Primary)</li>
        <li>Volatility 75 (1s) Index (Secondary)</li>
        <li>Volatility 10 Index (Tertiary)</li>
      </ul>
      <p>Data is processed in real-time using proprietary algorithms that convert tick-level information into actionable trading signals.</p>

      <h3>3.2 Signal Generation Algorithm</h3>
      <ul>
        <li>Processes real-time market data</li>
        <li>Identifies momentum shifts and trend reversals</li>
        <li>Generates entry and exit signals</li>
        <li>Maintains non-repainting characteristics to ensure live trading accuracy</li>
      </ul>

      <h3>3.3 Risk Management Framework</h3>
      <ul>
        <li>Dynamic position sizing based on performance metrics</li>
        <li>Real-time drawdown monitoring</li>
        <li>Automatic position adjustment algorithms</li>
        <li>Market condition adaptation mechanisms</li>
      </ul>

      <h2>4. Empirical Results</h2>
      <h3>4.1 Primary Performance Metrics</h3>
      <table>
        <thead>
          <tr><th>Metric</th><th>Value</th><th>Significance</th></tr>
        </thead>
        <tbody>
          <tr><td><strong>Primary Index Return</strong></td><td>10,521,583.90%</td><td>Demonstrates exceptional scalability</td></tr>
          <tr><td><strong>Risk-Adjusted Return</strong></td><td>3,495,878.4</td><td>Superior risk management efficiency</td></tr>
          <tr><td><strong>Maximum Drawdown</strong></td><td>3.01%</td><td>Exceptional capital preservation</td></tr>
          <tr><td><strong>Signal Accuracy</strong></td><td>81.6%</td><td>High-quality signal generation</td></tr>
          <tr><td><strong>Risk-Reward Ratio</strong></td><td>4.52:1</td><td>Optimal risk-return balance</td></tr>
          <tr><td><strong>24h Avg. Profit Factor</strong></td><td>20.06</td><td>Consistent profitability over daily windows</td></tr>
        </tbody>
      </table>

      <h3>4.2 Cross-Index Performance Validation</h3>
      <ul>
        <li><strong>Volatility 100 Index</strong>: 10,521,583.90% return, 3.01% max drawdown</li>
        <li><strong>Volatility 75 (1s) Index</strong>: 2,301,628.73% return, 5.14% max drawdown</li>
      </ul>
      <p>This consistency validates the model's robustness across different volatility regimes and market conditions.</p>

      <h3>4.3 Statistical Significance</h3>
      <ul>
        <li><strong>Sample Size</strong>: 125+ trading signals across multiple indices</li>
        <li><strong>Time Period</strong>: Extended testing across 24-hour to 30-day periods</li>
        <li><strong>Market Conditions</strong>: Performance maintained across varying volatility environments</li>
        <li><strong>Risk Metrics</strong>: Consistent risk-adjusted returns across all test scenarios</li>
      </ul>

      <h2>5. Discussion</h2>
      <h3>5.1 The Sophisticated Simplicity Advantage</h3>
      <ul>
        <li><strong>Minimize Overfitting</strong>: Simple algorithms are less prone to historical data overfitting</li>
        <li><strong>Maximize Adaptability</strong>: Clean architecture allows for rapid market condition adaptation</li>
        <li><strong>Optimize Execution</strong>: Reduced computational complexity enables faster signal processing</li>
        <li><strong>Enhance Robustness</strong>: Simpler systems demonstrate greater stability across market regimes</li>
      </ul>

      <h3>5.2 Market Microstructure Insights</h3>
      <ul>
        <li><strong>Volatility Persistence</strong>: Higher volatility indices provide more trading opportunities</li>
        <li><strong>Momentum Efficiency</strong>: The model effectively captures momentum shifts in volatile environments</li>
        <li><strong>Risk Scaling</strong>: Position sizing algorithms successfully adapt to varying volatility levels</li>
      </ul>

      <h3>5.3 Position Sizing Innovation</h3>
      <ul>
        <li><strong>Performance-Based Adjustment</strong>: Position sizes automatically scale with win rate performance</li>
        <li><strong>Risk-Aware Scaling</strong>: Kelly Criterion implementation ensures optimal capital utilization</li>
        <li><strong>Market Condition Adaptation</strong>: Algorithm adjusts to changing volatility environments</li>
      </ul>

      <h2>6. Implications and Future Research</h2>
      <h3>6.1 Industry Implications</h3>
      <ul>
        <li><strong>Paradigm Shift</strong>: Challenges the assumption that complexity equals performance</li>
        <li><strong>Risk Management</strong>: Demonstrates superior risk-adjusted returns through adaptive algorithms</li>
        <li><strong>Scalability</strong>: Proves that simple systems can achieve exceptional performance at scale</li>
      </ul>

      <h3>6.2 Future Research Directions</h3>
      <ul>
        <li><strong>Multi-Asset Application</strong>: Testing the model across different asset classes</li>
        <li><strong>Machine Learning Integration</strong>: Combining sophisticated simplicity with advanced ML techniques</li>
        <li><strong>Real-Time Adaptation</strong>: Further development of adaptive algorithms for live trading</li>
        <li><strong>Regulatory Considerations</strong>: Analysis of the model's compliance with financial regulations</li>
      </ul>

      <h2>7. Conclusion</h2>
      <p>
        The METACOGNITION model represents a fundamental breakthrough in algorithmic trading, demonstrating that sophisticated simplicity can achieve superior performance compared to complex, multi-factor systems. Through the application of advanced market microstructure analysis and adaptive position sizing algorithms, the model achieves unprecedented returns while maintaining exceptional risk management.
      </p>
      <p>
        Our research establishes that the future of algorithmic trading lies not in increasing complexity, but in the elegant application of sophisticated simplicity. The METACOGNITION model serves as a paradigm for how mathematical elegance, combined with deep market understanding, can create systems that outperform traditional approaches while maintaining robustness and scalability.
      </p>
      <p>
        The implications of this research extend beyond algorithmic trading, suggesting that across multiple domains, the most effective solutions often emerge from the elegant application of simple principles rather than the accumulation of complex components.
      </p>

      <hr />
      <section class="footer">
        <p><strong>Keywords</strong>: Algorithmic Trading, Market Microstructure, Position Sizing, Risk Management, Sophisticated Simplicity, Volatility Indices, Kelly Criterion, Performance Optimization</p>
        <p><strong>Author</strong>: METACOGNITION Research Team<br/>
        <strong>Institution</strong>: METACOGNITION Trading Research<br/>
        <strong>Date</strong>: 2025</p>
      </section>
    </article>
  </main>
</body>
</html>

<script>
  // ASCII Binary Flow engine (5x slower) for hero background
  (function(){
    class AsciiField{
      constructor(container, opts={}){
        this.el = container;
        this.w = opts.w || 65; this.h = opts.h || 40;
        this.blockSize = opts.blockSize || 30;
        this.speed = opts.speed || 0.2; // 0.2 => ~5x slower
        this.phase = opts.phase || 0;
        this.grid = [];
        this.time = 0;
        this.initGrid();
      }
      initGrid(){ this.grid = new Array(this.h).fill(null).map(()=> new Array(this.w).fill(' ')); }
      setSize(w,h){ this.w=w; this.h=h; this.initGrid(); }
      update(){
        const w=this.w,h=this.h,grid=this.grid; for(let y=0;y<h;y++){ for(let x=0;x<w;x++) grid[y][x]=' '; }
        const bs = Math.min(this.blockSize, Math.floor(Math.min(w,h)*0.6));
        const bx = Math.floor(w/2 - bs/2), by = Math.floor(h/2 - bs/2);
        const t = (this.time + this.phase) * 0.005;
        for(let y=0;y<h;y++){
          for(let x=0;x<w;x++){
            if(x>=bx && x<bx+bs && y>=by && y<by+bs){
              const innerDist = Math.min(x-bx, bx+bs-x, y-by, by+bs-y);
              const erosion = (this.time + this.phase) * 0.0067;
              grid[y][x] = innerDist > erosion ? '1' : (Math.random()>0.8 ? '1':'0');
            }else{
              const dx = x - w/2, dy = y - h/2;
              const angle = Math.atan2(dy, dx), dist = Math.hypot(dx, dy);
              const wave = Math.sin(dist*0.2 - t + angle*1.5);
              const flow = Math.sin(x*0.08 + y*0.04 + t*0.4);
              const s = flow + wave;
              if(s > 0.4) grid[y][x] = '0'; else if(s < -0.4) grid[y][x] = '~';
            }
          }
        }
        for(let i=0;i<5;i++){
          let cx = bx + Math.floor(Math.random()*bs);
          let cy = by + Math.floor(Math.random()*bs);
          const length = Math.floor(Math.random()*10)+5;
          for(let j=0;j<length;j++){
            if(cx>=0 && cx<w && cy>=0 && cy<h) grid[cy][cx]='0';
            cx += Math.floor(Math.random()*3)-1; cy += Math.floor(Math.random()*3)-1;
          }
        }
        this.time += this.speed; // slower
      }
      render(){
        let html='';
        for(let y=0;y<this.h;y++){
          for(let x=0;x<this.w;x++) html += this.grid[y][x];
          html += '<br>';
        }
        this.el.innerHTML = html;
      }
    }

    // Hero field
    const heroEl = document.getElementById('ascii-flow');
    const fields = [];
    if(heroEl){
      const heroField = new AsciiField(heroEl, { w:65, h:65, blockSize:30, speed:0.2, phase:0 });
      fields.push(heroField);
      const onResize = ()=>{
        const hero = document.querySelector('.hero'); if(!hero) return;
        const w = hero.clientWidth, h = hero.clientHeight || 400;
        const charsW = Math.max(40, Math.min(120, Math.floor(w/12)));
        const charsH = Math.max(30, Math.min(90, Math.floor(h/14)));
        heroField.setSize(charsW, charsH);
      };
      window.addEventListener('resize', onResize); onResize();
    }

    // Single RAF loop
    let rafId = 0;
    function tick(){
      for(const f of fields){ f.update(); f.render(); }
      rafId = requestAnimationFrame(tick);
    }
    function start(){ if(rafId) cancelAnimationFrame(rafId); rafId = requestAnimationFrame(tick); }
    start();
  })();
</script>

<!-- React + Three.js particle visualization replacing the logo -->
<script type="module">
  import React, { useEffect, useRef } from 'https://esm.sh/react@18.3.1';
  import { createRoot } from 'https://esm.sh/react-dom@18.3.1/client';
  import * as THREE from 'https://esm.sh/three@0.158.0';

  const metadata = {
    themes: "Source, Radiance, Forgiveness",
    visualization: "Particles radiating from a central source in gentle waves",
    promptSuggestion: "1. Add subtle radiance variations\n2. Create source-centered waves\n3. Vary emanation patterns naturally\n4. Introduce gentle pulse rhythms\n5. Make radiance follow natural flows"
  };

  const ParticleCylinder = () => {
    const containerRef = useRef(null);
    useEffect(() => {
      if (!containerRef.current) return;
      const container = containerRef.current;

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, container.clientWidth / Math.max(1, container.clientHeight), 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, Math.max(1, container.clientHeight));
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setClearColor(0xF0EEE6, 0); // transparent to blend with header
      container.appendChild(renderer.domElement);

      camera.position.z = 6.25;

      const particleMaterial = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 }, opacity: { value: 0.4 } },
        vertexShader: `
          uniform float time;
          attribute float size;
          attribute vec3 customColor;
          varying vec3 vColor;
          float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
          void main(){
            vColor = customColor;
            vec3 pos = position;
            float radius = length(pos.xz);
            float angle = atan(pos.z, pos.x);
            float height = pos.y;
            float pulse = sin(time * 2.0) * 0.2 + 0.8;
            float wave = sin(radius * 3.0 - time * 3.0) * 0.2;
            float verticalWave = cos(radius * 2.0 - time * 1.5) * 0.3;
            float rotationSpeed = 0.05 / (radius + 1.0);
            float newAngle = angle + time * rotationSpeed;
            vec3 newPos;
            newPos.x = cos(newAngle) * (radius + wave) * pulse;
            newPos.z = sin(newAngle) * (radius + wave) * pulse;
            newPos.y = height + verticalWave;
            newPos *= 2.34375;
            pos = newPos;
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = size * (100.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          uniform float opacity;
          varying vec3 vColor;
          void main(){
            float dist = length(gl_PointCoord - vec2(0.5));
            if (dist > 0.5) discard;
            float alpha = (1.0 - smoothstep(0.45, 0.5, dist)) * opacity;
            gl_FragColor = vec4(vColor, alpha);
          }
        `,
        transparent: true,
        depthWrite: false
      });

      const count = 37500;
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);
      const sizes = new Float32Array(count);
      for (let i = 0; i < count; i++){
        const t = i / count;
        const radius = Math.pow(t, 0.5);
        const angle = t * Math.PI * 30.0;
        const height = (Math.random() - 0.5) * 2.0;
        positions[i*3] = Math.cos(angle) * radius;
        positions[i*3+1] = height;
        positions[i*3+2] = Math.sin(angle) * radius;
        const centerDist = Math.sqrt(radius);
        const baseShade = 0.02 + centerDist * 0.13;
        const variation = Math.random() * 0.05;
        const shade = baseShade + variation;
        colors[i*3] = shade; colors[i*3+1] = shade; colors[i*3+2] = shade;
        sizes[i] = (1.0 - centerDist) * 0.164 + 0.133;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      const points = new THREE.Points(geometry, particleMaterial);
      scene.add(points);

      const clock = new THREE.Clock();
      let rafId = 0;
      const animate = () => {
        rafId = requestAnimationFrame(animate);
        const t = clock.getElapsedTime() * 0.4;
        particleMaterial.uniforms.time.value = t;
        renderer.render(scene, camera);
      };
      animate();

      const handleResize = () => {
        const w = Math.max(1, container.clientWidth);
        const h = Math.max(1, container.clientHeight);
        camera.aspect = w / h; camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      };
      window.addEventListener('resize', handleResize);

      return () => {
        window.removeEventListener('resize', handleResize);
        if (rafId) cancelAnimationFrame(rafId);
        if (renderer){ renderer.dispose(); if (container.contains(renderer.domElement)) container.removeChild(renderer.domElement); }
        geometry.dispose(); particleMaterial.dispose();
      };
    }, []);

    return (
      React.createElement('div', { ref: containerRef, style: {
        margin: 0,
        background: 'transparent',
        overflow: 'hidden',
        display: 'block',
        height: '100%',
        width: '100%'
      }})
    );
  };
  ParticleCylinder.metadata = metadata;

  const mount = document.getElementById('logo-react');
  if (mount){
    const root = createRoot(mount);
    root.render(React.createElement(ParticleCylinder));
  }
</script>
